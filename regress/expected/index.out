/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
LOAD 'age';
SET search_path TO ag_catalog;
SET enable_mergejoin = ON;
SET enable_hashjoin = ON;
SET enable_nestloop = ON;
SET enable_seqscan = false;
SELECT create_graph('cypher_index');
NOTICE:  graph "cypher_index" has been created
 create_graph 
--------------
 
(1 row)

/*
 * Section 1: Unique Index on Properties
 */
--Section 1 Setup
SELECT create_vlabel('cypher_index', 'idx');
NOTICE:  VLabel "idx" has been created
 create_vlabel 
---------------
 
(1 row)

CREATE UNIQUE INDEX cypher_index_idx_props_uq ON cypher_index.idx(properties);
--Test 1
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
ERROR:  duplicate key value violates unique constraint "cypher_index_idx_props_uq"
DETAIL:  Key (properties)=({"i": 1}) already exists.
--Clean Up
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

--Test 2
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}), (:idx {i: 1}) $$) AS (a agtype);
ERROR:  duplicate key value violates unique constraint "cypher_index_idx_props_uq"
DETAIL:  Key (properties)=({"i": 1}) already exists.
--Clean Up
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

--Test 3
--Data Setup
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

SELECT * FROM cypher('cypher_index', $$ CREATE (:idx) $$) AS (a agtype);
 a 
---
(0 rows)

--Query
SELECT * FROM cypher('cypher_index', $$ MATCH(n) SET n.i = 1$$) AS (a agtype);
ERROR:  duplicate key value violates unique constraint "cypher_index_idx_props_uq"
DETAIL:  Key (properties)=({"i": 1}) already exists.
--Clean Up
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

--Test 4
--create a vertex with i = 1
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

--delete the vertex
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

--we should be able to create a new vertex with the same value
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

--data cleanup
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

/*
 * Test 5
 *
 * Same queries as Test 4, only in 1 transaction
 */
BEGIN TRANSACTION;
--create a vertex with i = 1
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

--delete the vertex
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

--we should be able to create a new vertex with the same value
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

COMMIT;
--data cleanup
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

--Test 6
--create a vertex with i = 1
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

-- change the value
SELECT * FROM cypher('cypher_index', $$ MATCH(n) SET n.i = 2 $$) AS (a agtype);
 a 
---
(0 rows)

--we should be able to create a new vertex with the same value
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

--validate the data
SELECT * FROM cypher('cypher_index', $$ MATCH(n) RETURN n $$) AS (a agtype);
                                    a                                    
-------------------------------------------------------------------------
 {"id": 844424930131979, "label": "idx", "properties": {"i": 2}}::vertex
 {"id": 844424930131980, "label": "idx", "properties": {"i": 1}}::vertex
(2 rows)

--data cleanup
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

/*
 * Test 7
 *
 * Same queries as Test 6, only in 1 transaction
 */
BEGIN TRANSACTION;
--create a vertex with i = 1
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

-- change the value
SELECT * FROM cypher('cypher_index', $$ MATCH(n) SET n.i = 2 $$) AS (a agtype);
 a 
---
(0 rows)

--we should be able to create a new vertex with the same value
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

--validate the data
SELECT * FROM cypher('cypher_index', $$ MATCH(n) RETURN n $$) AS (a agtype);
                                    a                                    
-------------------------------------------------------------------------
 {"id": 844424930131981, "label": "idx", "properties": {"i": 2}}::vertex
 {"id": 844424930131982, "label": "idx", "properties": {"i": 1}}::vertex
(2 rows)

COMMIT;
--validate the data again out of the transaction, just in case
SELECT * FROM cypher('cypher_index', $$ MATCH(n) RETURN n $$) AS (a agtype);
                                    a                                    
-------------------------------------------------------------------------
 {"id": 844424930131981, "label": "idx", "properties": {"i": 2}}::vertex
 {"id": 844424930131982, "label": "idx", "properties": {"i": 1}}::vertex
(2 rows)

--data cleanup
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

--Test 8
--create a vertex with i = 1
SELECT * FROM cypher('cypher_index', $$ CREATE (:idx {i: 1}) $$) AS (a agtype);
 a 
---
(0 rows)

-- Use Merge and force an index error
SELECT * FROM cypher('cypher_index', $$ MATCH(n) MERGE (n)-[:e]->(:idx {i: n.i}) $$) AS (a agtype);
ERROR:  duplicate key value violates unique constraint "cypher_index_idx_props_uq"
DETAIL:  Key (properties)=({"i": 1}) already exists.
--data cleanup
SELECT * FROM cypher('cypher_index', $$ MATCH(n) DETACH DELETE n $$) AS (a agtype);
 a 
---
(0 rows)

/*
 * Section 2: Graphid Indices to Improve Join Performance
 */
SELECT * FROM cypher('cypher_index', $$
    CREATE (us:Country {name: "United States", country_code: "US", life_expectancy: 78.79, gdp: 20.94::numeric}),
        (ca:Country {name: "Canada", country_code: "CA", life_expectancy: 82.05, gdp: 1.643::numeric}),
        (mx:Country {name: "Mexico", country_code: "MX", life_expectancy: 75.05, gdp: 1.076::numeric}),
        (us)<-[:has_city]-(:City {city_id: 1, name:"New York", west_coast: false, country_code:"US"}),
        (us)<-[:has_city]-(:City {city_id: 2, name:"San Fransisco", west_coast: true, country_code:"US"}),
        (us)<-[:has_city]-(:City {city_id: 3, name:"Los Angeles", west_coast: true, country_code:"US"}),
        (us)<-[:has_city]-(:City {city_id: 4, name:"Seattle", west_coast: true, country_code:"US"}),
        (ca)<-[:has_city]-(:City {city_id: 5, name:"Vancouver", west_coast: true, country_code:"CA"}),
        (ca)<-[:has_city]-(:City {city_id: 6, name:"Toronto", west_coast: false, country_code:"CA"}),
        (ca)<-[:has_city]-(:City {city_id: 7, name:"Montreal", west_coast: false, country_code:"CA"}),
        (mx)<-[:has_city]-(:City {city_id: 8, name:"Mexico City", west_coast: false, country_code:"MX"}),
        (mx)<-[:has_city]-(:City {city_id: 9, name:"Monterrey", west_coast: false, country_code:"MX"}),
        (mx)<-[:has_city]-(:City {city_id: 10, name:"Tijuana", west_coast: false, country_code:"MX"})
$$) as (n agtype);
 n 
---
(0 rows)

-- Verify that the incices are created on id columns
SELECT indexname, indexdef FROM pg_indexes WHERE schemaname= 'cypher_index' ORDER BY 1;
          indexname          |                                            indexdef                                            
-----------------------------+------------------------------------------------------------------------------------------------
 City_pkey                   | CREATE UNIQUE INDEX "City_pkey" ON cypher_index."City" USING btree (id)
 Country_pkey                | CREATE UNIQUE INDEX "Country_pkey" ON cypher_index."Country" USING btree (id)
 _ag_label_edge_end_id_idx   | CREATE INDEX _ag_label_edge_end_id_idx ON cypher_index._ag_label_edge USING btree (end_id)
 _ag_label_edge_pkey         | CREATE UNIQUE INDEX _ag_label_edge_pkey ON cypher_index._ag_label_edge USING btree (id)
 _ag_label_edge_start_id_idx | CREATE INDEX _ag_label_edge_start_id_idx ON cypher_index._ag_label_edge USING btree (start_id)
 _ag_label_vertex_pkey       | CREATE UNIQUE INDEX _ag_label_vertex_pkey ON cypher_index._ag_label_vertex USING btree (id)
 cypher_index_idx_props_uq   | CREATE UNIQUE INDEX cypher_index_idx_props_uq ON cypher_index.idx USING btree (properties)
 has_city_end_id_idx         | CREATE INDEX has_city_end_id_idx ON cypher_index.has_city USING btree (end_id)
 has_city_start_id_idx       | CREATE INDEX has_city_start_id_idx ON cypher_index.has_city USING btree (start_id)
 idx_pkey                    | CREATE UNIQUE INDEX idx_pkey ON cypher_index.idx USING btree (id)
(10 rows)

SET enable_mergejoin = ON;
SET enable_hashjoin = OFF;
SET enable_nestloop = OFF;
SELECT COUNT(*) FROM cypher('cypher_index', $$
    MATCH (a:Country)<-[e:has_city]-()
    RETURN e
$$) as (n agtype);
 count 
-------
    10
(1 row)

SELECT COUNT(*) FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (a:Country)<-[e:has_city]-()
    RETURN e
$$) as (n agtype);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Merge Join
         Merge Cond: (_age_default_alias_0.id = e.start_id)
         ->  Merge Append
               Sort Key: _age_default_alias_0.id
               ->  Index Only Scan using _ag_label_vertex_pkey on _ag_label_vertex _age_default_alias_0_1
               ->  Index Only Scan using idx_pkey on idx _age_default_alias_0_2
               ->  Index Only Scan using "Country_pkey" on "Country" _age_default_alias_0_3
               ->  Index Only Scan using "City_pkey" on "City" _age_default_alias_0_4
         ->  Sort
               Sort Key: e.start_id
               ->  Merge Join
                     Merge Cond: (a.id = e.end_id)
                     ->  Index Only Scan using "Country_pkey" on "Country" a
                     ->  Index Scan using has_city_end_id_idx on has_city e
(15 rows)

SET enable_mergejoin = OFF;
SET enable_hashjoin = ON;
SET enable_nestloop = OFF;
SELECT COUNT(*) FROM cypher('cypher_index', $$
    MATCH (a:Country)<-[e:has_city]-()
    RETURN e
$$) as (n agtype);
 count 
-------
    10
(1 row)

SELECT COUNT(*) FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (a:Country)<-[e:has_city]-()
    RETURN e
$$) as (n agtype);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Hash Join
         Hash Cond: (_age_default_alias_0.id = e.start_id)
         ->  Append
               ->  Index Only Scan using _ag_label_vertex_pkey on _ag_label_vertex _age_default_alias_0_1
               ->  Index Only Scan using idx_pkey on idx _age_default_alias_0_2
               ->  Index Only Scan using "Country_pkey" on "Country" _age_default_alias_0_3
               ->  Index Only Scan using "City_pkey" on "City" _age_default_alias_0_4
         ->  Hash
               ->  Hash Join
                     Hash Cond: (e.end_id = a.id)
                     ->  Index Scan using has_city_end_id_idx on has_city e
                     ->  Hash
                           ->  Index Only Scan using "Country_pkey" on "Country" a
(14 rows)

SET enable_mergejoin = OFF;
SET enable_hashjoin = OFF;
SET enable_nestloop = ON;
SELECT COUNT(*) FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (a:Country)<-[e:has_city]-()
    RETURN e
$$) as (n agtype);
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Nested Loop
         ->  Nested Loop
               ->  Index Scan using has_city_start_id_idx on has_city e
               ->  Index Only Scan using "Country_pkey" on "Country" a
                     Index Cond: (id = e.end_id)
         ->  Append
               ->  Index Only Scan using _ag_label_vertex_pkey on _ag_label_vertex _age_default_alias_0_1
                     Index Cond: (id = e.start_id)
               ->  Index Only Scan using idx_pkey on idx _age_default_alias_0_2
                     Index Cond: (id = e.start_id)
               ->  Index Only Scan using "Country_pkey" on "Country" _age_default_alias_0_3
                     Index Cond: (id = e.start_id)
               ->  Index Only Scan using "City_pkey" on "City" _age_default_alias_0_4
                     Index Cond: (id = e.start_id)
(15 rows)

SET enable_mergejoin = ON;
SET enable_hashjoin = ON;
SET enable_nestloop = ON;
--
-- Section 3: Agtype GIN Indices to Improve WHERE clause Performance
--
CREATE INDEX load_city_gin_idx
ON cypher_index."City" USING gin (properties);
CREATE INDEX load_country_gin_idx
ON cypher_index."Country" USING gin (properties);
-- Verify GIN index is used for City property match
SELECT * FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (c:City {city_id: 1})
    RETURN c
$$) as (plan agtype);
                          QUERY PLAN                          
--------------------------------------------------------------
 Bitmap Heap Scan on "City" c
   Recheck Cond: (properties @> '{"city_id": 1}'::agtype)
   ->  Bitmap Index Scan on load_city_gin_idx
         Index Cond: (properties @> '{"city_id": 1}'::agtype)
(4 rows)

SELECT * FROM cypher('cypher_index', $$
    MATCH (c:City {city_id: 1})
    RETURN c
$$) as (n agtype);
                                                                       n                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------
 {"id": 1970324836974593, "label": "City", "properties": {"name": "New York", "city_id": 1, "west_coast": false, "country_code": "US"}}::vertex
(1 row)

SELECT * FROM cypher('cypher_index', $$
    MATCH (:Country {country_code: "US"})<-[]-(city:City)
    RETURN city
$$) as (n agtype);
                                                                         n                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------
 {"id": 1970324836974593, "label": "City", "properties": {"name": "New York", "city_id": 1, "west_coast": false, "country_code": "US"}}::vertex
 {"id": 1970324836974594, "label": "City", "properties": {"name": "San Fransisco", "city_id": 2, "west_coast": true, "country_code": "US"}}::vertex
 {"id": 1970324836974595, "label": "City", "properties": {"name": "Los Angeles", "city_id": 3, "west_coast": true, "country_code": "US"}}::vertex
 {"id": 1970324836974596, "label": "City", "properties": {"name": "Seattle", "city_id": 4, "west_coast": true, "country_code": "US"}}::vertex
(4 rows)

SELECT * FROM cypher('cypher_index', $$
    MATCH (c:City {west_coast: true})
    RETURN c
$$) as (n agtype);
                                                                         n                                                                          
----------------------------------------------------------------------------------------------------------------------------------------------------
 {"id": 1970324836974594, "label": "City", "properties": {"name": "San Fransisco", "city_id": 2, "west_coast": true, "country_code": "US"}}::vertex
 {"id": 1970324836974595, "label": "City", "properties": {"name": "Los Angeles", "city_id": 3, "west_coast": true, "country_code": "US"}}::vertex
 {"id": 1970324836974596, "label": "City", "properties": {"name": "Seattle", "city_id": 4, "west_coast": true, "country_code": "US"}}::vertex
 {"id": 1970324836974597, "label": "City", "properties": {"name": "Vancouver", "city_id": 5, "west_coast": true, "country_code": "CA"}}::vertex
(4 rows)

-- Verify GIN index is used for Country property match
SELECT * FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (c:Country {life_expectancy: 82.05})
    RETURN c
$$) as (plan agtype);
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Bitmap Heap Scan on "Country" c
   Recheck Cond: (properties @> '{"life_expectancy": 82.05}'::agtype)
   ->  Bitmap Index Scan on load_country_gin_idx
         Index Cond: (properties @> '{"life_expectancy": 82.05}'::agtype)
(4 rows)

SELECT * FROM cypher('cypher_index', $$
    MATCH (c:Country {life_expectancy: 82.05})
    RETURN c
$$) as (n agtype);
                                                                               n                                                                               
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 {"id": 1407374883553282, "label": "Country", "properties": {"gdp": 1.643::numeric, "name": "Canada", "country_code": "CA", "life_expectancy": 82.05}}::vertex
(1 row)

SELECT * FROM cypher('cypher_index', $$
    MATCH (c:Country {gdp: 20.94::numeric})
    RETURN c
$$) as (n agtype);
                                                                                  n                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 {"id": 1407374883553281, "label": "Country", "properties": {"gdp": 20.94::numeric, "name": "United States", "country_code": "US", "life_expectancy": 78.79}}::vertex
(1 row)

DROP INDEX cypher_index.load_city_gin_idx;
DROP INDEX cypher_index.load_country_gin_idx;
--
-- Section 4: Index use with WHERE clause
--
-- Create expression index on country_code property
CREATE INDEX city_country_code_idx ON cypher_index."City"
(ag_catalog.agtype_access_operator(properties, '"country_code"'::agtype));
-- Verify index is used with EXPLAIN (should show Index Scan on city_country_code_idx)
SELECT * FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (a:City)
    WHERE a.country_code = 'US'
    RETURN a
$$) as (plan agtype);
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Index Scan using city_country_code_idx on "City" a
   Index Cond: (agtype_access_operator(VARIADIC ARRAY[properties, '"country_code"'::agtype]) = '"US"'::agtype)
(2 rows)

-- Test WHERE with indexed string property
SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.country_code = 'US'
    RETURN a.name
    ORDER BY a.city_id
$$) as (name agtype);
      name       
-----------------
 "New York"
 "San Fransisco"
 "Los Angeles"
 "Seattle"
(4 rows)

SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.country_code = 'CA'
    RETURN a.name
    ORDER BY a.city_id
$$) as (name agtype);
    name     
-------------
 "Vancouver"
 "Toronto"
 "Montreal"
(3 rows)

-- Test WHERE with no matching results
SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.country_code = 'XX'
    RETURN a.name
$$) as (name agtype);
 name 
------
(0 rows)

-- Create expression index on city_id property
CREATE INDEX city_id_idx ON cypher_index."City"
(ag_catalog.agtype_access_operator(properties, '"city_id"'::agtype));
-- Verify index is used with EXPLAIN for integer property
SELECT * FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (a:City)
    WHERE a.city_id = 1
    RETURN a
$$) as (plan agtype);
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Index Scan using city_id_idx on "City" a
   Index Cond: (agtype_access_operator(VARIADIC ARRAY[properties, '"city_id"'::agtype]) = '1'::agtype)
(2 rows)

-- Test WHERE with indexed integer property
SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.city_id = 1
    RETURN a.name
$$) as (name agtype);
    name    
------------
 "New York"
(1 row)

SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.city_id = 5
    RETURN a.name
$$) as (name agtype);
    name     
-------------
 "Vancouver"
(1 row)

-- Test WHERE with comparison operators on indexed property
SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.city_id < 3
    RETURN a.name
    ORDER BY a.city_id
$$) as (name agtype);
      name       
-----------------
 "New York"
 "San Fransisco"
(2 rows)

SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.city_id >= 8
    RETURN a.name
    ORDER BY a.city_id
$$) as (name agtype);
    name     
-------------
 "Monterrey"
 "Tijuana"
(2 rows)

-- Create expression index on west_coast boolean property
CREATE INDEX city_west_coast_idx ON cypher_index."City"
(ag_catalog.agtype_access_operator(properties, '"west_coast"'::agtype));
-- Verify index is used with EXPLAIN for boolean property
SELECT * FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (a:City)
    WHERE a.west_coast = true
    RETURN a
$$) as (plan agtype);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Index Scan using city_west_coast_idx on "City" a
   Index Cond: (agtype_access_operator(VARIADIC ARRAY[properties, '"west_coast"'::agtype]) = 'true'::agtype)
(2 rows)

-- Test WHERE with indexed boolean property
SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.west_coast = true
    RETURN a.name
    ORDER BY a.city_id
$$) as (name agtype);
      name       
-----------------
 "San Fransisco"
 "Los Angeles"
 "Seattle"
 "Vancouver"
(4 rows)

SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.west_coast = false
    RETURN a.name
    ORDER BY a.city_id
$$) as (name agtype);
     name      
---------------
 "New York"
 "Toronto"
 "Montreal"
 "Mexico City"
 "Monterrey"
 "Tijuana"
(6 rows)

-- EXPLAIN for pattern with WHERE clause
SELECT * FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (a:City)
    WHERE a.country_code = 'US' AND a.west_coast = true
    RETURN a
$$) as (plan agtype);
                                                 QUERY PLAN                                                  
-------------------------------------------------------------------------------------------------------------
 Index Scan using city_west_coast_idx on "City" a
   Index Cond: (agtype_access_operator(VARIADIC ARRAY[properties, '"west_coast"'::agtype]) = 'true'::agtype)
   Filter: (agtype_access_operator(VARIADIC ARRAY[properties, '"country_code"'::agtype]) = '"US"'::agtype)
(3 rows)

-- Test WHERE with multiple conditions (AND)
SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.country_code = 'US' AND a.west_coast = true
    RETURN a.name
    ORDER BY a.city_id
$$) as (name agtype);
      name       
-----------------
 "San Fransisco"
 "Los Angeles"
 "Seattle"
(3 rows)

-- Test WHERE with OR conditions
SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE a.city_id = 1 OR a.city_id = 5
    RETURN a.name
    ORDER BY a.city_id
$$) as (name agtype);
    name     
-------------
 "New York"
 "Vancouver"
(2 rows)

-- Test WHERE with NOT
SELECT * FROM cypher('cypher_index', $$
    MATCH (a:City)
    WHERE NOT a.west_coast = true AND a.country_code = 'US'
    RETURN a.name
$$) as (name agtype);
    name    
------------
 "New York"
(1 row)

-- Create expression index on life_expectancy for Country
CREATE INDEX country_life_exp_idx ON cypher_index."Country"
(ag_catalog.agtype_access_operator(properties, '"life_expectancy"'::agtype));
-- Verify index is used with EXPLAIN for float property
SELECT * FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (c:Country)
    WHERE c.life_expectancy > 80.0
    RETURN c
$$) as (plan agtype);
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Index Scan using country_life_exp_idx on "Country" c
   Index Cond: (agtype_access_operator(VARIADIC ARRAY[properties, '"life_expectancy"'::agtype]) > '80.0'::agtype)
(2 rows)

-- Test WHERE with float property
SELECT * FROM cypher('cypher_index', $$
    MATCH (c:Country)
    WHERE c.life_expectancy > 80.0
    RETURN c.name
$$) as (name agtype);
   name   
----------
 "Canada"
(1 row)

SELECT * FROM cypher('cypher_index', $$
    MATCH (c:Country)
    WHERE c.life_expectancy < 76.0
    RETURN c.name
$$) as (name agtype);
   name   
----------
 "Mexico"
(1 row)

-- EXPLAIN for pattern with filters on both country and city
SELECT * FROM cypher('cypher_index', $$
    EXPLAIN (costs off) MATCH (country:Country)<-[:has_city]-(city:City)
    WHERE country.country_code = 'CA' AND city.west_coast = true
    RETURN city.name
$$) as (plan agtype);
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Nested Loop
   ->  Nested Loop
         ->  Index Scan using city_west_coast_idx on "City" city
               Index Cond: (agtype_access_operator(VARIADIC ARRAY[properties, '"west_coast"'::agtype]) = 'true'::agtype)
         ->  Bitmap Heap Scan on has_city _age_default_alias_0
               Recheck Cond: (start_id = city.id)
               ->  Bitmap Index Scan on has_city_start_id_idx
                     Index Cond: (start_id = city.id)
   ->  Index Scan using "Country_pkey" on "Country" country
         Index Cond: (id = _age_default_alias_0.end_id)
         Filter: (agtype_access_operator(VARIADIC ARRAY[properties, '"country_code"'::agtype]) = '"CA"'::agtype)
(11 rows)

-- Test WHERE in combination with pattern matching
SELECT * FROM cypher('cypher_index', $$
    MATCH (country:Country)<-[:has_city]-(city:City)
    WHERE country.country_code = 'CA'
    RETURN city.name
    ORDER BY city.city_id
$$) as (name agtype);
    name     
-------------
 "Vancouver"
 "Toronto"
 "Montreal"
(3 rows)

-- Clean up indices
DROP INDEX cypher_index.city_country_code_idx;
DROP INDEX cypher_index.city_id_idx;
DROP INDEX cypher_index.city_west_coast_idx;
DROP INDEX cypher_index.country_life_exp_idx;
--
-- General Cleanup
--
SELECT drop_graph('cypher_index', true);
NOTICE:  drop cascades to 6 other objects
DETAIL:  drop cascades to table cypher_index._ag_label_vertex
drop cascades to table cypher_index._ag_label_edge
drop cascades to table cypher_index.idx
drop cascades to table cypher_index."Country"
drop cascades to table cypher_index.has_city
drop cascades to table cypher_index."City"
NOTICE:  graph "cypher_index" has been dropped
 drop_graph 
------------
 
(1 row)

