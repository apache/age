/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
--
-- Regression tests for the unified vertex table architecture
--
-- Tests verify:
--   1. Labels column correctly stores label table OID
--   2. Label retrieval from labels column works correctly
--   3. Multiple labels coexist in single table
--   4. startNode/endNode correctly retrieve vertex labels
--   5. VLE correctly handles label retrieval
--
LOAD 'age';
SET search_path TO ag_catalog;
--
-- Test 1: Basic unified table structure verification
--
SELECT create_graph('unified_test');
NOTICE:  graph "unified_test" has been created
 create_graph 
--------------
 
(1 row)

-- Create vertices with different labels
SELECT * FROM cypher('unified_test', $$
    CREATE (:Person {name: 'Alice'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:Company {name: 'Acme Corp'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:Location {name: 'Seattle'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify all vertices are in the unified table
SELECT COUNT(*) AS vertex_count FROM unified_test._ag_label_vertex;
 vertex_count 
--------------
            3
(1 row)

-- Verify labels column contains different OIDs for different labels
SELECT COUNT(DISTINCT labels) AS distinct_label_count FROM unified_test._ag_label_vertex;
 distinct_label_count 
----------------------
                    3
(1 row)

-- Verify we can filter by label using the labels column
SELECT id, properties FROM unified_test._ag_label_vertex
WHERE labels = 'unified_test."Person"'::regclass::oid;
       id        |    properties     
-----------------+-------------------
 844424930131969 | {"name": "Alice"}
(1 row)

SELECT id, properties FROM unified_test._ag_label_vertex
WHERE labels = 'unified_test."Company"'::regclass::oid;
        id        |      properties       
------------------+-----------------------
 1125899906842625 | {"name": "Acme Corp"}
(1 row)

SELECT id, properties FROM unified_test._ag_label_vertex
WHERE labels = 'unified_test."Location"'::regclass::oid;
        id        |     properties      
------------------+---------------------
 1407374883553281 | {"name": "Seattle"}
(1 row)

--
-- Test 2: Label retrieval via Cypher MATCH
--
SELECT * FROM cypher('unified_test', $$
    MATCH (p:Person) RETURN p.name ORDER BY p.name
$$) AS (name agtype);
  name   
---------
 "Alice"
(1 row)

SELECT * FROM cypher('unified_test', $$
    MATCH (c:Company) RETURN c.name ORDER BY c.name
$$) AS (name agtype);
    name     
-------------
 "Acme Corp"
(1 row)

SELECT * FROM cypher('unified_test', $$
    MATCH (n) RETURN labels(n), n.name ORDER BY n.name
$$) AS (label agtype, name agtype);
    label     |    name     
--------------+-------------
 ["Company"]  | "Acme Corp"
 ["Person"]   | "Alice"
 ["Location"] | "Seattle"
(3 rows)

--
-- Test 3: startNode/endNode label retrieval
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:Person {name: 'Bob'})-[:WORKS_AT]->(:Company {name: 'Tech Inc'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:Person {name: 'Carol'})-[:LIVES_IN]->(:Location {name: 'Portland'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify startNode returns correct label
SELECT * FROM cypher('unified_test', $$
    MATCH ()-[e:WORKS_AT]->()
    RETURN startNode(e).name AS employee, label(startNode(e)) AS emp_label,
           endNode(e).name AS company, label(endNode(e)) AS comp_label
$$) AS (employee agtype, emp_label agtype, company agtype, comp_label agtype);
 employee | emp_label |  company   | comp_label 
----------+-----------+------------+------------
 "Bob"    | "Person"  | "Tech Inc" | "Company"
(1 row)

SELECT * FROM cypher('unified_test', $$
    MATCH ()-[e:LIVES_IN]->()
    RETURN startNode(e).name AS person, label(startNode(e)) AS person_label,
           endNode(e).name AS location, label(endNode(e)) AS loc_label
$$) AS (person agtype, person_label agtype, location agtype, loc_label agtype);
 person  | person_label |  location  | loc_label  
---------+--------------+------------+------------
 "Carol" | "Person"     | "Portland" | "Location"
(1 row)

--
-- Test 4: Unlabeled vertices (default vertex label)
--
SELECT * FROM cypher('unified_test', $$
    CREATE ({type: 'unlabeled_1'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE ({type: 'unlabeled_2'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify unlabeled vertices have empty string label
SELECT * FROM cypher('unified_test', $$
    MATCH (n) WHERE n.type IS NOT NULL
    RETURN n.type, label(n) ORDER BY n.type
$$) AS (type agtype, label agtype);
     type      | label 
---------------+-------
 "unlabeled_1" | ""
 "unlabeled_2" | ""
(2 rows)

-- Verify labels column for default vertices points to unified table
SELECT COUNT(*) AS unlabeled_count FROM unified_test._ag_label_vertex
WHERE labels = 'unified_test._ag_label_vertex'::regclass::oid;
 unlabeled_count 
-----------------
               2
(1 row)

--
-- Test 5: Mixed label queries (MATCH without label)
--
SELECT * FROM cypher('unified_test', $$
    MATCH (n)
    RETURN label(n), count(*) AS cnt
    ORDER BY label(n)
$$) AS (label agtype, cnt agtype);
   label    | cnt 
------------+-----
 ""         | 2
 "Company"  | 2
 "Location" | 2
 "Person"   | 3
(4 rows)

--
-- Test 6: Label with SET operations
--
SELECT * FROM cypher('unified_test', $$
    MATCH (p:Person {name: 'Alice'})
    SET p.age = 30
    RETURN p.name, p.age, label(p)
$$) AS (name agtype, age agtype, label agtype);
  name   | age |  label   
---------+-----+----------
 "Alice" | 30  | "Person"
(1 row)

-- Verify label is preserved after SET
SELECT * FROM cypher('unified_test', $$
    MATCH (p:Person {name: 'Alice'})
    RETURN label(p)
$$) AS (label agtype);
  label   
----------
 "Person"
(1 row)

--
-- Test 7: MERGE with labels
--
SELECT * FROM cypher('unified_test', $$
    MERGE (d:Department {name: 'Engineering'})
    RETURN d.name, label(d)
$$) AS (name agtype, label agtype);
     name      |    label     
---------------+--------------
 "Engineering" | "Department"
(1 row)

SELECT * FROM cypher('unified_test', $$
    MERGE (d:Department {name: 'Engineering'})
    RETURN d.name, label(d)
$$) AS (name agtype, label agtype);
     name      |    label     
---------------+--------------
 "Engineering" | "Department"
(1 row)

-- Verify only one Department vertex exists
SELECT * FROM cypher('unified_test', $$
    MATCH (d:Department)
    RETURN count(d)
$$) AS (cnt agtype);
 cnt 
-----
 1
(1 row)

--
-- Test 8: DELETE preserves labels column integrity
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:Temporary {id: 1})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:Temporary {id: 2})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify vertices exist
SELECT * FROM cypher('unified_test', $$
    MATCH (t:Temporary)
    RETURN t.id ORDER BY t.id
$$) AS (id agtype);
 id 
----
 1
 2
(2 rows)

-- Delete one
SELECT * FROM cypher('unified_test', $$
    MATCH (t:Temporary {id: 1})
    DELETE t
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify remaining vertex still has correct label
SELECT * FROM cypher('unified_test', $$
    MATCH (t:Temporary)
    RETURN t.id, label(t)
$$) AS (id agtype, label agtype);
 id |    label    
----+-------------
 2  | "Temporary"
(1 row)

--
-- Test 9: VLE with label retrieval
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:Node {name: 'a'})-[:CONNECTED]->(:Node {name: 'b'})-[:CONNECTED]->(:Node {name: 'c'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Test that VLE path returns vertices with correct labels
SELECT * FROM cypher('unified_test', $$
    MATCH p = (n:Node {name: 'a'})-[:CONNECTED*1..2]->(m)
    RETURN label(n), label(m)
    ORDER BY label(m)
$$) AS (start_label agtype, end_label agtype);
 start_label | end_label 
-------------+-----------
 "Node"      | "Node"
 "Node"      | "Node"
(2 rows)

--
-- Test 10: _label_name_from_table_oid function
--
-- Get a label table OID and verify function works
SELECT ag_catalog._label_name_from_table_oid('unified_test."Person"'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 Person
(1 row)

SELECT ag_catalog._label_name_from_table_oid('unified_test."Company"'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 Company
(1 row)

SELECT ag_catalog._label_name_from_table_oid('unified_test."Location"'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 Location
(1 row)

--
-- Test 11: Verify all labels coexist in unified table with distinct OIDs
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:LabelA {val: 1})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:LabelB {val: 2})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:LabelC {val: 3})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify all have distinct label OIDs (count should equal 3)
SELECT COUNT(DISTINCT labels) AS distinct_labels FROM unified_test._ag_label_vertex
WHERE properties::text LIKE '%val%';
 distinct_labels 
-----------------
               3
(1 row)

--
-- Test 12: Index scan optimization for vertex_exists()
-- This exercises the systable_beginscan path in vertex_exists()
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:IndexTest {id: 100})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:IndexTest {id: 101})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:IndexTest {id: 102})
$$) AS (v agtype);
 v 
---
(0 rows)

-- DETACH DELETE exercises vertex_exists() to check vertex validity
SELECT * FROM cypher('unified_test', $$
    MATCH (n:IndexTest {id: 100})
    DETACH DELETE n
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify vertex was deleted and others remain
SELECT * FROM cypher('unified_test', $$
    MATCH (n:IndexTest)
    RETURN n.id ORDER BY n.id
$$) AS (id agtype);
 id  
-----
 101
 102
(2 rows)

-- Multiple deletes to exercise index scan repeatedly
SELECT * FROM cypher('unified_test', $$
    MATCH (n:IndexTest)
    DELETE n
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify all IndexTest vertices are gone
SELECT * FROM cypher('unified_test', $$
    MATCH (n:IndexTest)
    RETURN count(n)
$$) AS (cnt agtype);
 cnt 
-----
 0
(1 row)

--
-- Test 13: Index scan optimization for get_vertex() via startNode/endNode
-- This exercises the systable_beginscan path in get_vertex()
--
SELECT * FROM cypher('unified_test', $$
    CREATE (a:GetVertexTest {name: 'source1'})-[:LINK]->(b:GetVertexTest {name: 'target1'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (a:GetVertexTest {name: 'source2'})-[:LINK]->(b:GetVertexTest {name: 'target2'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (a:GetVertexTest {name: 'source3'})-[:LINK]->(b:GetVertexTest {name: 'target3'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Multiple startNode/endNode calls exercise get_vertex() with index scans
SELECT * FROM cypher('unified_test', $$
    MATCH ()-[e:LINK]->()
    RETURN startNode(e).name AS src, endNode(e).name AS tgt,
           label(startNode(e)) AS src_label, label(endNode(e)) AS tgt_label
    ORDER BY src
$$) AS (src agtype, tgt agtype, src_label agtype, tgt_label agtype);
    src    |    tgt    |    src_label    |    tgt_label    
-----------+-----------+-----------------+-----------------
 "source1" | "target1" | "GetVertexTest" | "GetVertexTest"
 "source2" | "target2" | "GetVertexTest" | "GetVertexTest"
 "source3" | "target3" | "GetVertexTest" | "GetVertexTest"
(3 rows)

-- Chain of edges to test repeated get_vertex calls
SELECT * FROM cypher('unified_test', $$
    MATCH (a:GetVertexTest {name: 'target1'})
    CREATE (a)-[:CHAIN]->(:GetVertexTest {name: 'chain1'})-[:CHAIN]->(:GetVertexTest {name: 'chain2'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    MATCH ()-[e:CHAIN]->()
    RETURN startNode(e).name, endNode(e).name
    ORDER BY startNode(e).name
$$) AS (src agtype, tgt agtype);
    src    |   tgt    
-----------+----------
 "chain1"  | "chain2"
 "target1" | "chain1"
(2 rows)

--
-- Test 14: Index scan optimization for process_delete_list()
-- This exercises the F_INT8EQ fix and systable_beginscan in DELETE
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:DeleteTest {seq: 1}), (:DeleteTest {seq: 2}), (:DeleteTest {seq: 3}),
           (:DeleteTest {seq: 4}), (:DeleteTest {seq: 5})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify vertices exist
SELECT * FROM cypher('unified_test', $$
    MATCH (n:DeleteTest)
    RETURN n.seq ORDER BY n.seq
$$) AS (seq agtype);
 seq 
-----
 1
 2
 3
 4
 5
(5 rows)

-- Delete specific vertex by property (exercises index lookup)
SELECT * FROM cypher('unified_test', $$
    MATCH (n:DeleteTest {seq: 3})
    DELETE n
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify correct vertex was deleted
SELECT * FROM cypher('unified_test', $$
    MATCH (n:DeleteTest)
    RETURN n.seq ORDER BY n.seq
$$) AS (seq agtype);
 seq 
-----
 1
 2
 4
 5
(4 rows)

-- Delete with edges (exercises process_delete_list with edge cleanup)
SELECT * FROM cypher('unified_test', $$
    MATCH (a:DeleteTest {seq: 1})
    CREATE (a)-[:DEL_EDGE]->(:DeleteTest {seq: 10})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    MATCH (n:DeleteTest {seq: 1})
    DETACH DELETE n
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify vertex and edge were deleted
SELECT * FROM cypher('unified_test', $$
    MATCH (n:DeleteTest)
    RETURN n.seq ORDER BY n.seq
$$) AS (seq agtype);
 seq 
-----
 2
 4
 5
 10
(4 rows)

--
-- Test 15: Index scan optimization for process_update_list()
-- This exercises the systable_beginscan in SET/REMOVE operations
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:UpdateTest {id: 1, val: 'original1'}),
           (:UpdateTest {id: 2, val: 'original2'}),
           (:UpdateTest {id: 3, val: 'original3'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Single SET operation
SELECT * FROM cypher('unified_test', $$
    MATCH (n:UpdateTest {id: 1})
    SET n.val = 'updated1'
    RETURN n.id, n.val
$$) AS (id agtype, val agtype);
 id |    val     
----+------------
 1  | "updated1"
(1 row)

-- Multiple SET operations in one query (exercises repeated index lookups)
SELECT * FROM cypher('unified_test', $$
    MATCH (n:UpdateTest)
    SET n.modified = true
    RETURN n.id, n.val, n.modified ORDER BY n.id
$$) AS (id agtype, val agtype, modified agtype);
 id |     val     | modified 
----+-------------+----------
 1  | "updated1"  | true
 2  | "original2" | true
 3  | "original3" | true
(3 rows)

-- SET with property addition
SELECT * FROM cypher('unified_test', $$
    MATCH (n:UpdateTest {id: 2})
    SET n.extra = 'new_property', n.val = 'updated2'
    RETURN n.id, n.val, n.extra
$$) AS (id agtype, val agtype, extra agtype);
 id |    val     |     extra      
----+------------+----------------
 2  | "updated2" | "new_property"
(1 row)

-- REMOVE property operation
SELECT * FROM cypher('unified_test', $$
    MATCH (n:UpdateTest {id: 3})
    REMOVE n.val
    RETURN n.id, n.val, n.modified
$$) AS (id agtype, val agtype, modified agtype);
 id | val | modified 
----+-----+----------
 3  |     | true
(1 row)

-- Verify final state of all UpdateTest vertices
SELECT * FROM cypher('unified_test', $$
    MATCH (n:UpdateTest)
    RETURN n ORDER BY n.id
$$) AS (n agtype);
                                                                       n                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------
 {"id": 5910974510923777, "label": "UpdateTest", "properties": {"id": 1, "val": "updated1", "modified": true}}::vertex
 {"id": 5910974510923778, "label": "UpdateTest", "properties": {"id": 2, "val": "updated2", "extra": "new_property", "modified": true}}::vertex
 {"id": 5910974510923779, "label": "UpdateTest", "properties": {"id": 3, "modified": true}}::vertex
(3 rows)

--
-- Test 16: OID caching in _label_name_from_table_oid()
-- Repeated calls should use cache after first lookup
--
-- Call multiple times to exercise cache hit path
SELECT ag_catalog._label_name_from_table_oid('unified_test."Person"'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 Person
(1 row)

SELECT ag_catalog._label_name_from_table_oid('unified_test."Person"'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 Person
(1 row)

SELECT ag_catalog._label_name_from_table_oid('unified_test."Company"'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 Company
(1 row)

SELECT ag_catalog._label_name_from_table_oid('unified_test."Company"'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 Company
(1 row)

SELECT ag_catalog._label_name_from_table_oid('unified_test."Location"'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 Location
(1 row)

SELECT ag_catalog._label_name_from_table_oid('unified_test."Location"'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 Location
(1 row)

-- Call with unified table OID (default vertex label case)
SELECT ag_catalog._label_name_from_table_oid('unified_test._ag_label_vertex'::regclass::oid);
 _label_name_from_table_oid 
----------------------------
 
(1 row)

-- Verify label function also benefits from caching (exercises full path)
SELECT * FROM cypher('unified_test', $$
    MATCH (p:Person)
    RETURN label(p), label(p), label(p)
$$) AS (l1 agtype, l2 agtype, l3 agtype);
    l1    |    l2    |    l3    
----------+----------+----------
 "Person" | "Person" | "Person"
 "Person" | "Person" | "Person"
 "Person" | "Person" | "Person"
(3 rows)

--
-- Test 17: Combined operations stress test
-- Multiple operations in sequence to verify optimizations work together
--
SELECT * FROM cypher('unified_test', $$
    CREATE (a:StressTest {id: 1})-[:ST_EDGE]->(b:StressTest {id: 2})
$$) AS (v agtype);
 v 
---
(0 rows)

-- startNode/endNode (get_vertex index scan)
SELECT * FROM cypher('unified_test', $$
    MATCH ()-[e:ST_EDGE]->()
    RETURN startNode(e).id, endNode(e).id
$$) AS (start_id agtype, end_id agtype);
 start_id | end_id 
----------+--------
 1        | 2
(1 row)

-- SET (process_update_list index scan)
SELECT * FROM cypher('unified_test', $$
    MATCH (n:StressTest)
    SET n.updated = true
    RETURN n.id, n.updated ORDER BY n.id
$$) AS (id agtype, updated agtype);
 id | updated 
----+---------
 1  | true
 2  | true
(2 rows)

-- label() calls (OID cache)
SELECT * FROM cypher('unified_test', $$
    MATCH (n:StressTest)
    RETURN n.id, label(n) ORDER BY n.id
$$) AS (id agtype, lbl agtype);
 id |     lbl      
----+--------------
 1  | "StressTest"
 2  | "StressTest"
(2 rows)

-- DETACH DELETE (vertex_exists + process_delete_list index scans)
SELECT * FROM cypher('unified_test', $$
    MATCH (n:StressTest)
    DETACH DELETE n
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify cleanup
SELECT * FROM cypher('unified_test', $$
    MATCH (n:StressTest)
    RETURN count(n)
$$) AS (cnt agtype);
 cnt 
-----
 0
(1 row)

--
-- Test 18: SET label operation - error when vertex already has a label
-- Multiple labels are not supported. SET only works on unlabeled vertices.
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:OldLabel {id: 1, name: 'vertex1'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:OldLabel {id: 2, name: 'vertex2'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify initial label
SELECT * FROM cypher('unified_test', $$
    MATCH (n:OldLabel)
    RETURN n.id, n.name, label(n) ORDER BY n.id
$$) AS (id agtype, name agtype, lbl agtype);
 id |   name    |    lbl     
----+-----------+------------
 1  | "vertex1" | "OldLabel"
 2  | "vertex2" | "OldLabel"
(2 rows)

-- Try to change label on vertex1 - should FAIL because it already has a label
SELECT * FROM cypher('unified_test', $$
    MATCH (n:OldLabel {id: 1})
    SET n:NewLabel
    RETURN n.id, n.name, label(n)
$$) AS (id agtype, name agtype, lbl agtype);
ERROR:  SET label failed: vertex already has label "OldLabel"
HINT:  Multiple labels are not supported. Use REMOVE to clear the label first.
-- Verify vertex1 still has OldLabel (unchanged due to error)
SELECT * FROM cypher('unified_test', $$
    MATCH (n:OldLabel)
    RETURN n.id, n.name, label(n) ORDER BY n.id
$$) AS (id agtype, name agtype, lbl agtype);
 id |   name    |    lbl     
----+-----------+------------
 1  | "vertex1" | "OldLabel"
 2  | "vertex2" | "OldLabel"
(2 rows)

--
-- Test 19: REMOVE label operation
-- This tests removing a vertex's label using REMOVE n:Label syntax
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:RemoveTest {id: 1, data: 'test1'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    CREATE (:RemoveTest {id: 2, data: 'test2'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Verify initial label
SELECT * FROM cypher('unified_test', $$
    MATCH (n:RemoveTest)
    RETURN n.id, n.data, label(n) ORDER BY n.id
$$) AS (id agtype, data agtype, lbl agtype);
 id |  data   |     lbl      
----+---------+--------------
 1  | "test1" | "RemoveTest"
 2  | "test2" | "RemoveTest"
(2 rows)

-- Remove label from vertex1
SELECT * FROM cypher('unified_test', $$
    MATCH (n:RemoveTest {id: 1})
    REMOVE n:RemoveTest
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id |  data   | lbl 
----+---------+-----
 1  | "test1" | ""
(1 row)

-- Verify vertex1 now has no label (empty string)
SELECT * FROM cypher('unified_test', $$
    MATCH (n {data: 'test1'})
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id |  data   | lbl 
----+---------+-----
 1  | "test1" | ""
(1 row)

-- Verify vertex2 still has RemoveTest label
SELECT * FROM cypher('unified_test', $$
    MATCH (n:RemoveTest)
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id |  data   |     lbl      
----+---------+--------------
 2  | "test2" | "RemoveTest"
(1 row)

-- Verify properties are preserved after label removal
SELECT * FROM cypher('unified_test', $$
    MATCH (n)
    WHERE n.data = 'test1'
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id |  data   | lbl 
----+---------+-----
 1  | "test1" | ""
(1 row)

--
-- Test 20: SET label with property updates - error when vertex has label
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:CombinedTest {id: 1, val: 'original'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Try to SET label and property - should FAIL because vertex has a label
SELECT * FROM cypher('unified_test', $$
    MATCH (n:CombinedTest {id: 1})
    SET n:CombinedNew, n.val = 'updated'
    RETURN n.id, n.val, label(n)
$$) AS (id agtype, val agtype, lbl agtype);
ERROR:  SET label failed: vertex already has label "CombinedTest"
HINT:  Multiple labels are not supported. Use REMOVE to clear the label first.
-- Verify vertex is unchanged
SELECT * FROM cypher('unified_test', $$
    MATCH (n:CombinedTest)
    RETURN n.id, n.val, label(n) ORDER BY n.id
$$) AS (id agtype, val agtype, lbl agtype);
 id |    val     |      lbl       
----+------------+----------------
 1  | "original" | "CombinedTest"
(1 row)

--
-- Test 21: Proper workflow - REMOVE then SET label
-- To change a label, first REMOVE the old one, then SET the new one
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:WorkflowTest {id: 50, val: 'workflow'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- First REMOVE the label
SELECT * FROM cypher('unified_test', $$
    MATCH (n:WorkflowTest {id: 50})
    REMOVE n:WorkflowTest
    RETURN n.id, n.val, label(n)
$$) AS (id agtype, val agtype, lbl agtype);
 id |    val     | lbl 
----+------------+-----
 50 | "workflow" | ""
(1 row)

-- Now SET a new label (should work because vertex has no label)
SELECT * FROM cypher('unified_test', $$
    MATCH (n {id: 50})
    SET n:NewWorkflowLabel
    RETURN n.id, n.val, label(n)
$$) AS (id agtype, val agtype, lbl agtype);
 id |    val     |        lbl         
----+------------+--------------------
 50 | "workflow" | "NewWorkflowLabel"
(1 row)

-- Verify the new label
SELECT * FROM cypher('unified_test', $$
    MATCH (n:NewWorkflowLabel)
    RETURN n.id, n.val, label(n) ORDER BY n.id
$$) AS (id agtype, val agtype, lbl agtype);
 id |    val     |        lbl         
----+------------+--------------------
 50 | "workflow" | "NewWorkflowLabel"
(1 row)

--
-- Test 22: SET label auto-creates label when vertex has no label
--
-- First create and remove label to get unlabeled vertex
SELECT * FROM cypher('unified_test', $$
    CREATE (:TempForAuto {id: 60, name: 'auto_create_test'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    MATCH (n:TempForAuto {id: 60})
    REMOVE n:TempForAuto
    RETURN n.id, n.name, label(n)
$$) AS (id agtype, name agtype, lbl agtype);
 id |        name        | lbl 
----+--------------------+-----
 60 | "auto_create_test" | ""
(1 row)

-- Now SET a new label that doesn't exist yet (should auto-create)
SELECT * FROM cypher('unified_test', $$
    MATCH (n {id: 60})
    SET n:AutoCreatedLabel
    RETURN n.id, n.name, label(n)
$$) AS (id agtype, name agtype, lbl agtype);
 id |        name        |        lbl         
----+--------------------+--------------------
 60 | "auto_create_test" | "AutoCreatedLabel"
(1 row)

-- Verify the new label exists and the vertex is there
SELECT * FROM cypher('unified_test', $$
    MATCH (n:AutoCreatedLabel)
    RETURN n.id, n.name, label(n)
$$) AS (id agtype, name agtype, lbl agtype);
 id |        name        |        lbl         
----+--------------------+--------------------
 60 | "auto_create_test" | "AutoCreatedLabel"
(1 row)

--
-- Test 23: SET label on vertex with NO label (blank -> labeled)
--
-- First create a vertex with a label, then remove it to get a blank label
SELECT * FROM cypher('unified_test', $$
    CREATE (:TempLabel {id: 100, data: 'unlabeled_test'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Remove the label to make it blank
SELECT * FROM cypher('unified_test', $$
    MATCH (n:TempLabel {id: 100})
    REMOVE n:TempLabel
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |       data       | lbl 
-----+------------------+-----
 100 | "unlabeled_test" | ""
(1 row)

-- Verify it has no label (blank)
SELECT * FROM cypher('unified_test', $$
    MATCH (n {id: 100})
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |       data       | lbl 
-----+------------------+-----
 100 | "unlabeled_test" | ""
(1 row)

-- Now SET a label on the unlabeled vertex
SELECT * FROM cypher('unified_test', $$
    MATCH (n {id: 100})
    SET n:FromBlankLabel
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |       data       |       lbl        
-----+------------------+------------------
 100 | "unlabeled_test" | "FromBlankLabel"
(1 row)

-- Verify the label was set
SELECT * FROM cypher('unified_test', $$
    MATCH (n:FromBlankLabel)
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |       data       |       lbl        
-----+------------------+------------------
 100 | "unlabeled_test" | "FromBlankLabel"
(1 row)

--
-- Test 24: REMOVE label on vertex that already has NO label (no-op)
--
-- Create another unlabeled vertex
SELECT * FROM cypher('unified_test', $$
    CREATE (:TempLabel2 {id: 101, data: 'already_blank'})
$$) AS (v agtype);
 v 
---
(0 rows)

SELECT * FROM cypher('unified_test', $$
    MATCH (n:TempLabel2 {id: 101})
    REMOVE n:TempLabel2
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |      data       | lbl 
-----+-----------------+-----
 101 | "already_blank" | ""
(1 row)

-- Now try to REMOVE a label from already-unlabeled vertex (should be no-op)
SELECT * FROM cypher('unified_test', $$
    MATCH (n {id: 101})
    REMOVE n:SomeLabel
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |      data       | lbl 
-----+-----------------+-----
 101 | "already_blank" | ""
(1 row)

-- Verify still has no label
SELECT * FROM cypher('unified_test', $$
    MATCH (n {id: 101})
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |      data       | lbl 
-----+-----------------+-----
 101 | "already_blank" | ""
(1 row)

--
-- Test 25: REMOVE with wrong label name (should be no-op)
-- REMOVE should only remove the label if it matches the specified name
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:KeepThisLabel {id: 103, data: 'wrong_label_test'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Try to REMOVE a different label than the vertex has - should be no-op
SELECT * FROM cypher('unified_test', $$
    MATCH (n:KeepThisLabel {id: 103})
    REMOVE n:WrongLabel
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |        data        |       lbl       
-----+--------------------+-----------------
 103 | "wrong_label_test" | "KeepThisLabel"
(1 row)

-- Verify label is still KeepThisLabel (unchanged)
SELECT * FROM cypher('unified_test', $$
    MATCH (n:KeepThisLabel {id: 103})
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |        data        |       lbl       
-----+--------------------+-----------------
 103 | "wrong_label_test" | "KeepThisLabel"
(1 row)

-- Now REMOVE with the correct label - should work
SELECT * FROM cypher('unified_test', $$
    MATCH (n:KeepThisLabel {id: 103})
    REMOVE n:KeepThisLabel
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |        data        | lbl 
-----+--------------------+-----
 103 | "wrong_label_test" | ""
(1 row)

-- Verify label is now empty
SELECT * FROM cypher('unified_test', $$
    MATCH (n {id: 103})
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |        data        | lbl 
-----+--------------------+-----
 103 | "wrong_label_test" | ""
(1 row)

--
-- Test 26: SET label to same label - error (vertex already has a label)
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:SameLabel {id: 102, data: 'same_label_test'})
$$) AS (v agtype);
 v 
---
(0 rows)

-- SET to the same label it already has - should FAIL
SELECT * FROM cypher('unified_test', $$
    MATCH (n:SameLabel {id: 102})
    SET n:SameLabel
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
ERROR:  SET label failed: vertex already has label "SameLabel"
HINT:  Multiple labels are not supported. Use REMOVE to clear the label first.
-- Verify label is unchanged
SELECT * FROM cypher('unified_test', $$
    MATCH (n:SameLabel {id: 102})
    RETURN n.id, n.data, label(n)
$$) AS (id agtype, data agtype, lbl agtype);
 id  |       data        |     lbl     
-----+-------------------+-------------
 102 | "same_label_test" | "SameLabel"
(1 row)

--
-- Test 27: Error case - SET/REMOVE label on edge (should error)
--
SELECT * FROM cypher('unified_test', $$
    CREATE (:EdgeTest1 {id: 200})-[:CONNECTS]->(:EdgeTest2 {id: 201})
$$) AS (v agtype);
 v 
---
(0 rows)

-- Try to SET label on an edge - should fail
SELECT * FROM cypher('unified_test', $$
    MATCH (:EdgeTest1)-[e:CONNECTS]->(:EdgeTest2)
    SET e:NewEdgeLabel
    RETURN e
$$) AS (e agtype);
ERROR:  SET/REMOVE label can only be used on vertices
-- Try to REMOVE label on an edge - should fail
SELECT * FROM cypher('unified_test', $$
    MATCH (:EdgeTest1)-[e:CONNECTS]->(:EdgeTest2)
    REMOVE e:CONNECTS
    RETURN e
$$) AS (e agtype);
ERROR:  SET/REMOVE label can only be used on vertices
--
-- Cleanup
--
SELECT drop_graph('unified_test', true);
NOTICE:  drop cascades to 38 other objects
DETAIL:  drop cascades to table unified_test._ag_label_vertex
drop cascades to table unified_test._ag_label_edge
drop cascades to table unified_test."Person"
drop cascades to table unified_test."Company"
drop cascades to table unified_test."Location"
drop cascades to table unified_test."WORKS_AT"
drop cascades to table unified_test."LIVES_IN"
drop cascades to table unified_test."Department"
drop cascades to table unified_test."Temporary"
drop cascades to table unified_test."Node"
drop cascades to table unified_test."CONNECTED"
drop cascades to table unified_test."LabelA"
drop cascades to table unified_test."LabelB"
drop cascades to table unified_test."LabelC"
drop cascades to table unified_test."IndexTest"
drop cascades to table unified_test."GetVertexTest"
drop cascades to table unified_test."LINK"
drop cascades to table unified_test."CHAIN"
drop cascades to table unified_test."DeleteTest"
drop cascades to table unified_test."DEL_EDGE"
drop cascades to table unified_test."UpdateTest"
drop cascades to table unified_test."StressTest"
drop cascades to table unified_test."ST_EDGE"
drop cascades to table unified_test."OldLabel"
drop cascades to table unified_test."RemoveTest"
drop cascades to table unified_test."CombinedTest"
drop cascades to table unified_test."WorkflowTest"
drop cascades to table unified_test."NewWorkflowLabel"
drop cascades to table unified_test."TempForAuto"
drop cascades to table unified_test."AutoCreatedLabel"
drop cascades to table unified_test."TempLabel"
drop cascades to table unified_test."FromBlankLabel"
drop cascades to table unified_test."TempLabel2"
drop cascades to table unified_test."KeepThisLabel"
drop cascades to table unified_test."SameLabel"
drop cascades to table unified_test."EdgeTest1"
drop cascades to table unified_test."CONNECTS"
drop cascades to table unified_test."EdgeTest2"
NOTICE:  graph "unified_test" has been dropped
 drop_graph 
------------
 
(1 row)

